# file: cfg_nodes.py
#
# This file defines nodes for advanced CFG modifications in the WanVideoWrapper framework.
# It includes a base class for parameter nodes, individual parameter nodes for each
# CFG algorithm, and a controller node (AdvancedCFGArgs) to manage them.
# The NODE_CLASS_MAPPINGS and NODE_DISPLAY_NAME_MAPPINGS dictionaries register
# the nodes with the framework for dynamic instantiation and UI display.

import logging
from typing import Tuple
from .cfg_utils import get_cfg_log_details

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
log = logging.getLogger(__name__)

# --- Node Registration ---
NODE_CLASS_MAPPINGS = {}
NODE_DISPLAY_NAME_MAPPINGS = {}


class CFGArgsNodeBase:
    """A base class for CFG parameter nodes to reduce code duplication."""
    RETURN_TYPES = ("CFG_ARGS",)
    RETURN_NAMES = ("cfg_settings",)
    FUNCTION = "process"
    CATEGORY = "WanVideoWrapper/CFG Modifiers"
    EXPERIMENTAL = True

    def process(self, **kwargs):
        """Processes the node's inputs."""
        kwargs["_node_name"] = self.__class__.__name__
        return (kwargs,)


class CFGSkimmingArgs(CFGArgsNodeBase):
    """
    Configures classic CFG Skimming algorithms to reduce artifacts in high-CFG generation. These algorithms use a skimming mask (`skim_mask`) to identify regions where conditional (`noise_pred_cond`) and unconditional (`noise_pred_uncond`) predictions conflict, potentially causing artifacts like color burn or noise. The mask is generated by analyzing sign agreement and guidance impact, then used to adjust predictions via blending or replacement. Each mode (`Single Scale`, `Replace`, `Linear Interpolation`, `Linear Interpolation Dual Scales`) offers different balancing strategies to preserve details while minimizing artifacts.
    """
    DESCRIPTION = """
    Configures classic CFG Skimming algorithms to enhance generation quality at high CFG scales. These methods create a skimming mask (`skim_mask`) based on sign agreement and guidance impact between conditional (`noise_pred_cond`) and unconditional (`noise_pred_uncond`) predictions. The mask identifies regions prone to artifacts (e.g., color burn, high-frequency noise) and adjusts predictions to reduce their impact. Available modes:
    - **Single Scale**: Adjusts both conditional and unconditional predictions using a single skimming scale (`Skimming_CFG`). Optionally neutralizes negative prompt influence with `full_skim_negative`.
    - **Replace**: Replaces unconditional prediction values with conditional ones in masked regions, aggressively reducing negative prompt influence.
    - **Linear Interpolation**: Blends conditional and unconditional predictions using a weighted average (`Skimming_CFG / cfg_scale`), smoothing transitions.
    - **Linear Interpolation Dual Scales**: Extends Linear Interpolation with separate skimming scales for positive (`Skimming_CFG`) and negative (`Skimming_CFG_negative`) prompts for finer control.
    Parameters control the strength and behavior of skimming, balancing artifact reduction against detail preservation.
    """
    
    @classmethod
    def INPUT_TYPES(cls):
        """Defines input parameters for classic CFG Skimming algorithms."""
        return {"required": {
            "mode": ("COMBO", {
                "options": ["Single Scale", "Replace", "Linear Interpolation", "Linear Interpolation Dual Scales"],
                "default": "Single Scale",
                "tooltip": "Selects the CFG Skimming algorithm. 'Single Scale' balances both prompts, 'Replace' aggressively neutralizes negative prompts, 'Linear Interpolation' smoothly blends predictions, and 'Linear Interpolation Dual Scales' allows separate control for positive and negative prompts."
            }),
            "Skimming_CFG": ("FLOAT", {"default": 2.0, "min": 0.0, "max": 7.0, "step": 0.5, "tooltip": "Target lower CFG scale for skimming (positive prompt). Lower values (e.g., 1.0-2.0) reduce artifacts more aggressively but may soften details. Used in all modes except 'Replace'."}),
            "Skimming_CFG_negative": ("FLOAT", {"default": 2.0, "min": 0.0, "max": 7.0, "step": 0.5, "tooltip": "Target lower CFG scale for negative prompt blending. Only used in 'Linear Interpolation Dual Scales' mode. Lower values reduce negative prompt influence."}),
            "full_skim_negative": ("BOOLEAN", {"default": False, "tooltip": "If enabled, sets the skimming scale for the negative prompt to 0 in 'Single Scale' mode, aggressively neutralizing its influence in high-conflict areas. Ignored in other modes."}),
            "disable_flipping_filter": ("BOOLEAN", {"default": False, "tooltip": "Disables the deviation influence filter in skimming mask generation, broadening the mask and strengthening the skimming effect. Used in 'Single Scale' only."}),
        }}

NODE_CLASS_MAPPINGS["CFGSkimmingArgs"] = CFGSkimmingArgs
NODE_DISPLAY_NAME_MAPPINGS["CFGSkimmingArgs"] = "CFG Skimming Args WIP+BETA"


class AMICFGArgs(CFGArgsNodeBase):
    """
    Controls AMI-CFG (Attention-Masked Interpolation). This method creates a
    semantic importance map based on prediction magnitude and applies stronger
    guidance reduction (blending) in less important/detailed areas.
    """
    DESCRIPTION = "Controls AMI-CFG. This method creates a semantic importance map (based on prediction magnitude) and applies stronger guidance reduction (blending) in less important/detailed areas, preserving detail in key subjects."

    @classmethod
    def INPUT_TYPES(cls):
        """Defines the inputs for AMI-CFG."""
        return {"required": {
            "alpha_base": ("FLOAT", {"default": 0.5, "min": 0.0, "max": 1.0, "step": 0.01, "tooltip": "Base strength of the blending applied to low-importance areas. Higher values lead to a more pronounced reduction of negative prompt influence."}),
            "power": ("FLOAT", {"default": 2.0, "min": 0.1, "max": 10.0, "step": 0.1, "tooltip": "Contrast exponent for the importance map. Higher values create a sharper distinction between important (less affected) and unimportant (more affected) areas."}),
        }}

NODE_CLASS_MAPPINGS["AMICFGArgs"] = AMICFGArgs
NODE_DISPLAY_NAME_MAPPINGS["AMICFGArgs"] = "CFG AMI-CFG Args WIP+BETA"


class PAGCFGArgs(CFGArgsNodeBase):
    """
    Controls PAG-CFG (Perceptual Adaptive Guidance). This method analyzes the
    entire guidance vector ('cond' - 'uncond') and scales down only the most
    extreme values that exceed a certain percentile, preventing pixel 'burn-out'.
    """
    DESCRIPTION = "Controls PAG-CFG. This method analyzes the entire guidance vector ('cond' - 'uncond') and scales down only the most extreme values that exceed a certain percentile. This prevents pixel 'burn-out' without altering the overall guidance direction."

    @classmethod
    def INPUT_TYPES(cls):
        """Defines the inputs for PAG-CFG."""
        return {"required": {
            "percentile": ("FLOAT", {"default": 0.95, "min": 0.0, "max": 1.0, "step": 0.01, "tooltip": "The threshold for clipping. At 0.95, any guidance signal in the top 5% of intensity will be scaled down to the 95th percentile level. Lowering this value strengthens the clipping effect."}),
        }}

NODE_CLASS_MAPPINGS["PAGCFGArgs"] = PAGCFGArgs
NODE_DISPLAY_NAME_MAPPINGS["PAGCFGArgs"] = "CFG PAG-CFG Args WIP+BETA"


class SSDTCFGArgs(CFGArgsNodeBase):
    """
    Controls SSDT-CFG (Scheduled Skimming w/ Dynamic Thresholding). This is a
    two-stage process: 1. Applies a guidance-reducing effect that weakens over
    time (Scheduled Skimming). 2. Applies Dynamic Thresholding to the final output.
    """
    DESCRIPTION = "Controls SSDT-CFG. This is a two-stage process. First, it applies a guidance-reducing effect that weakens over time (Scheduled Skimming). Second, it applies Dynamic Thresholding to the final output, clamping the brightest and darkest values to prevent 'sparkle' artifacts."

    @classmethod
    def INPUT_TYPES(cls):
        """Defines the inputs for SSDT-CFG."""
        return {"required": {
            "start_scale": ("FLOAT", {"default": 0.8, "min": 0.0, "max": 1.0, "step": 0.01, "tooltip": "Strength of the skimming effect at the start of sampling. 1.0 is minimal effect, 0.0 is a very strong blend towards the conditional prompt."}),
            "end_scale": ("FLOAT", {"default": 0.2, "min": 0.0, "max": 1.0, "step": 0.01, "tooltip": "Strength of the skimming effect at the end of sampling. 1.0 is minimal effect, 0.0 is a very strong blend."}),
            "schedule": ("COMBO", {"options": ["linear", "cosine"], "default": "linear", "tooltip": "The interpolation curve for the effect's strength as it progresses from start_scale to end_scale."}),
            "threshold_percentile": ("FLOAT", {"default": 0.99, "min": 0.0, "max": 1.0, "step": 0.001, "tooltip": "Final output clamp. At 0.99, it clamps the brightest/darkest 1% of values. Use this to remove extreme 'firefly' pixels without affecting the main image."}),
        }}

NODE_CLASS_MAPPINGS["SSDTCFGArgs"] = SSDTCFGArgs
NODE_DISPLAY_NAME_MAPPINGS["SSDTCFGArgs"] = "CFG SSDT-CFG Args WIP+BETA"


class LSSCFGArgs(CFGArgsNodeBase):
    """
    Controls LSS-CFG (Latent Space Smoothing). This method applies a gentle
    Gaussian blur to the negative conditioning ('uncond'), which has a regularizing
    effect, reducing high-frequency noise and improving smoothness.
    """
    DESCRIPTION = "Controls LSS-CFG. This method applies a gentle Gaussian blur to the negative conditioning ('uncond'). This has a regularizing effect, reducing high-frequency noise and improving overall image smoothness and coherence."
    
    @classmethod
    def INPUT_TYPES(cls):
        """Defines the inputs for LSS-CFG."""
        return {"required": {
            "beta": ("FLOAT", {"default": 0.6, "min": 0.0, "max": 1.0, "step": 0.01, "tooltip": "Blend factor between the original and blurred negative prompt. At 0.5, the negative prompt is a 50/50 mix. Higher values increase the smoothing effect."}),
            "kernel_size": ("INT", {"default": 3, "min": 1, "max": 15, "step": 2, "tooltip": "The size of the blur filter in pixels. Larger values result in a stronger, more spread-out blur. Must be an odd number."}),
            "sigma": ("FLOAT", {"default": 1.0, "min": 0.1, "max": 5.0, "step": 0.1, "tooltip": "The standard deviation of the Gaussian blur. Higher values create a more intense blur for a given kernel size."}),
        }}
    
    def process(self, **kwargs):
        """Ensures the kernel size is always an odd number."""
        if "kernel_size" in kwargs and kwargs["kernel_size"] % 2 == 0:
            kwargs["kernel_size"] += 1
        return super().process(**kwargs)

NODE_CLASS_MAPPINGS["LSSCFGArgs"] = LSSCFGArgs
NODE_DISPLAY_NAME_MAPPINGS["LSSCFGArgs"] = "CFG LSS-CFG Args WIP+BETA"


class AdvancedCFGArgs:
    """
    The central hub for activating and managing CFG modifications. It takes the
    settings from a connected parameter node and passes them to the sampler. Its
    sole purpose is to route the configuration.
    """
    DESCRIPTION = "The central hub for activating and managing CFG modifications. It takes the settings from a connected parameter node and passes them to the sampler. Its sole purpose is to route the configuration."
    
    RETURN_TYPES = ("CFG_ARGS", "STRING",)
    RETURN_NAMES = ("cfg_args", "log_details",)
    FUNCTION = "process"
    CATEGORY = "WanVideoWrapper"
    EXPERIMENTAL = True
    
    MODE_TO_NODE_MAP = {
        "Single Scale": "CFGSkimmingArgs", "Replace": "CFGSkimmingArgs",
        "Linear Interpolation": "CFGSkimmingArgs", "Linear Interpolation Dual Scales": "CFGSkimmingArgs",
        "AMI-CFG": "AMICFGArgs", "PAG-CFG": "PAGCFGArgs",
        "SSDT-CFG": "SSDTCFGArgs", "LSS-CFG": "LSSCFGArgs"
    }

    def __init__(self):
        """
        Initializes the node and pre-computes the reverse mapping 
        from node name to mode for efficient lookups.
        """
        from collections import defaultdict
        node_to_modes = defaultdict(list)
        for mode, node in self.MODE_TO_NODE_MAP.items():
            node_to_modes[node].append(mode)
        
        self.NODE_TO_MODE_MAP = {
            node: modes[0] for node, modes in node_to_modes.items() if len(modes) == 1
        }

    @classmethod
    def INPUT_TYPES(cls):
        """Defines the inputs for the main controller node."""
        return {
            "required": {
                "enabled": ("BOOLEAN", {"default": True, "tooltip": "A master switch to enable or disable the entire advanced CFG modification process."}),
                "verbose": ("BOOLEAN", {"default": False, "tooltip": "Enables detailed logging of the CFG modification process in the console. Essential for debugging and fine-tuning."}),
                "cfg_settings": ("CFG_ARGS", {"tooltip": "Input for a single parameter node (e.g., 'CFG Skimming Args'). The type of node connected determines the algorithm that will be used by the sampler."})
            }
        }

    def process(self, enabled: bool, verbose: bool, cfg_settings: dict) -> Tuple[dict, str]:
        """Validates inputs, packages them for the sampler, and generates a log summary."""
        if not enabled:
            return ({"enabled": False}, "Disabled",)
        
        final_args = {"enabled": True, "verbose": verbose}
        node_name = cfg_settings.get("_node_name")
        
        if node_name == "CFGSkimmingArgs":
            mode = cfg_settings.get("mode")
            if mode not in self.MODE_TO_NODE_MAP:
                log.warning(f"AdvancedCFGArgs: Invalid mode '{mode}' selected in CFGSkimmingArgs. The effect will be bypassed.")
                final_args["enabled"] = False
                return (final_args, "Error: Invalid Mode",)
        else:
            mode = self.NODE_TO_MODE_MAP.get(node_name)
            if not mode:
                log.warning(f"AdvancedCFGArgs: Connected node '{node_name}' is not recognized. The effect will be bypassed.")
                final_args["enabled"] = False
                return (final_args, f"Error: Unrecognized Node '{node_name}'",)
        
        if node_name != self.MODE_TO_NODE_MAP.get(mode):
            log.warning(f"AdvancedCFGArgs: Mode '{mode}' requires a '{self.MODE_TO_NODE_MAP.get(mode)}' node, but '{node_name}' is connected. The effect will be bypassed.")
            final_args["enabled"] = False
            return (final_args, f"Error: Mismatched Node for Mode '{mode}'",)
        
        final_args["mode"] = mode
        final_args.update(cfg_settings)

        # Call the imported function to get parameter details
        log_params = get_cfg_log_details(final_args)
        log_details = f"Mode: {mode}"
        if log_params and log_params != "invalid params":
            log_details += f" | {log_params}"
            # Additionally, append the threshold percentile for SSDT-CFG mode
            if mode == "SSDT-CFG":
                try:
                    percentile = final_args.get('threshold_percentile')
                    log_details += f", percentile={percentile:.3f}"
                except (TypeError, KeyError):
                    # Failsafe if the key is missing or not a number
                    log.warning("Could not append threshold_percentile to log details for SSDT-CFG.")

        return (final_args, log_details)

# Node registration for the framework
# Maps node identifiers to their classes and display names for UI integration
# Note: Display names include 'WIP+BETA' to indicate work-in-progress status
NODE_CLASS_MAPPINGS["AdvancedCFGArgs"] = AdvancedCFGArgs
NODE_DISPLAY_NAME_MAPPINGS["AdvancedCFGArgs"] = "CFG Advanced Control WIP+BETA"
# --- End of cfg_nodes.py ---